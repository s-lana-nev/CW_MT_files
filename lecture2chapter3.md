# Теория трансляции
## Метод рекурсивного спуска


Процесс грамматического разбора для этого метода состоит из отдельных процедур для каждого нетерминального символа, определённого в грамматике. Каждая такая процедура старается во входном потоке найти подстроку, начинающуюся с текущей лексемы, которая может быть интерпретирована как нетерминальный символ, связанный с данной процедурой. В процессе своей работы она может вызывать другие процедуры или даже рекурсивно саму себя для поиска других нетерминальных символов. Если эта процедура находит соответствующий нетерминальный символ, то она заканчивает работу и передаёт в вызывающую её программу признак успешного выполнения. Затем рассматривается следующая лексема, идущая за распознанной подстрокой. Если же процедура не может найти подстроку, которая могла бы быть интерпретирована как требуемый нетерминальный символ, она заканчивается с признаком неудачи или же вызывает процедуру диагностического сообщения.

Рассмотрим в качестве примера правило грамматики:

<ввод> —> read (<список переменных>)

Процедура метода рекурсивного спуска, соответствующая нетерми¬нальному символу <ввод>, прежде всего исследует две последовательные лексемы "read" и "(" В случае совпадения эта процедура вызывает другую процедуру, соответствующую нетерминальному символу <список переменных>. Если эта процедура закончится успешно, то процедура <ввод> сравнивает следующую лексему с ")". Если все эти проверки окажутся успешными, то процедура <ввод> завершается с признаком успеха и устанавливает указатель текущей лексемы на лексему, следующую за ")".

Ещё пример. Процедура, соответствующая нетерминальному символу <оператор> анализирует очередную лексему для того, чтобы выбрать одну из четырёх альтернатив:

<оператор> —> <присваивание>/<ввод>/<вывод>/<цикл>

Если это лексема read, то вызывается процедура <ввод>. Если это лексема, соответствующая символу идентификатор, то вызывается процедура <присваивание>, поскольку это единственная альтернатива, которая может начинаться с лексемы идентификатор, и т.д.

Но если мы попытаемся написать полный набор процедур для грамматики, то столкнёмся со следующей трудностью - процедура для нетерминала <список переменных> будет не в состоянии выбрать одну из двух альтернатив, поскольку обе альтернативы: ид и <список переменных> могут начинаться с лексемы ид.

<список переменных> —> ид / <список переменных>, ид

Тут скрыта и более существенная трудность. Если процедура каким- либо образом решит попробовать альтернативу <список переменных>/ ид, то она немедленно вызовет рекурсивно саму себя для поиска нетерминального символа <список переменных>. Это приведёт ещё к одному рекурсивному вызову и т.д., в результате чего образуется бесконечная цепочка рекурсивных вызовов. Те же проблемы возникнут и для некоторых других правил грамматики (<раздел переменных>, <раздел операторов>, <арифметическое выражение>, <слагаемое>). Как избежать такой рекурсии? Для этого применяют другую запись грамматики. Например:

<список переменных> —> ид {, ид }

Эта запись, являющаяся широко принятым расширением БНФ означает, что конструкция, заключённая в фигурные скобки, может быть либо опущена, либо повторяться один или более число раз. Таким образом, это правило определяет нетерминальный символ <список переменных> как состоящий из единственной лексемы ид или же из произвольного числа следующих друг за другом лексем ид, разделённых запятой. Это, бесспорно эквивалентно ранее принятому правилу. В соответствии с этим новым определением процедура<список переменных> сначала ищет лексему ид, а затем продолжает сканировать входной текст до тех пор, пока следующая пара лексем не совпадёт с запятой и ид. Такая запись устраняет проблему рекурсии, а также решает вопрос выбора из двух альтернатив. 

Грамматика языка, к которому принадлежит предложение, имеет вид:

    <программа> —> <имя программы> var <раздел переменных> begin <раздел операторов> end.  
    <имя программы> —> ид
    <раздел переменных> —> <список переменных>:<тип>
    <список переменных> —> ид {, ид }
    <тип> —> integer
    <раздел операторов> —> <оператор> {;<оператор>}
    <оператор> —> <присваивание>/<ввод>/<вывод>/<цикл>
    <присваивание> —> ид := <арифметическое выражение>
    <арифметическое выражение> —> <слагаемое> {+<слагаемое>}{-<слагаемое>}
    <слагаемое> —> <значение> {*<значение>} {div <значение>}
    <значение> —> ид/ конст/(<арифметическое выражение>)
    <ввод> —> read (<список переменных>)
    <вывод> —> write (<список переменных>) 
    <цикл> —> for <выражение цикла> to <тело цикла> 
    <выражение цикла> —> ид :=<арифметическое выражение> do <арифметическое выражение>
    <тело цикла> —> <оператор>/ begin <раздел операторов> end

Приведем примеры алгоритмов синтаксического анализа методом рекурсивного спуска для некоторых предложений исходной программы с использованием приведенной грамматики.
Имеем предложение исходной программы: READ (a).
Тогда процедура разбора этого предложения может иметь вид:
```pascal
    procedure <ввод>;
     begin
    	BP := false;
    	 if t = read then 
                   begin
    	  	перейти к следующей лексеме;
    		if  t = (  then
    	              begin
      		  	перейти к следующей лексеме;
    		 	if <список переменных> закончилась успешно then
    		              if t  = )  then 
    			       begin
    			             BP := true;
        			  	   перейти к следующей лексеме;
    			       end; {if )}		
    	  	    end; {if (}
    	     end; {if read}
	         if BP = true then успешное завершение
	    	else неудачное завершение;
     	 end;
```

В приведенной процедуре BP - вспомогательная переменная, а t- переменная, определяющая тип лексемы. Процедура, соответствующая нетерминальному символу <ввод> вызывает процедуру <список переменных>:

```pascal
    procedure <список переменных>;
          begin
    	 BP := false;
    	 if t=ид then 
    	     begin
    	  	BP := true;
     		перейти к следующей лексеме;
    		while ( t = , )  and  ( BP = true ) do		
	      	      begin
      		           перейти к следующей лексеме;
  	    	           if t = ид  then перейти к следующей лексеме
	    		            else BP := false;
	    	      end; {while}	
      	           if BP = true then успешное завершение
    		                     else неудачное завершение;
          end;
```

На схеме ниже графически представлен процесс грамматического разбора методом рекурсивного спуска для предложения READ.	На фрагменте (а) изображен вызов процедуры <ввод>,  которая обнаружила лексемы READ и (  во входном  потоке (штриховая линия). 

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМРСА.PNG)

На фрагменте (б) процедура <ввод> вызывает процедуру <список переменных> (сплошная линия), которая обработала лексему ид.

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМРСБ.PNG)


На фрагменте (в) процедура <список переменных> закончила работу, передала управление процедуре <ввод> с признаком успешного завершения; процедура <ввод> обработала входную лексему ). На этом анализ входного предложения завершён.

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМРСВ.PNG)


Приведём ещё один пример. Имеем предложение из исходной программы:
```pascal
REZ := SUM DIV 100 – A * A
```
Представим алгоритмы разбора этого предложения методом рекурсивного спуска:

```pascal
	procedure <присваивание>
              begin
	         BP := false;
	         if  t  =  ид   then
		   begin
	                   перейти к следующей лексеме;
		         if t  =   :=   then
			  begin
		        перейти к следующей лексеме;
      	                  if <арифметическое выражение> завершилось  
                                                                                   успешно then
                                           BP := true;
			  end; {if :=}
		   end;  {if ид.}
	             if BP = true then успешное завершение
		             else неудачное завершение;
	  end;
```

Процедура присваивание в процессе работы вызывает процедуру <арифметическое выражение>:

```pascal
    procedure арифметическое выражение;
        begin
     	BP:=false;
    	if  <слагаемое>  завершилось успешно then
    	    begin
     		BP:=true;
    		while (t = +  или  t = - ) and ( BP=true ) do
    		     begin
    			Перейти к следующей лексеме;
    			if  <слагаемое>  завершилось неудачно then
     			    BP:=false;	
    		      end; {while}
    	    end; {if слагаемое}
    	if  BP = true then успешное завершение 
    	    else неудачное завершение;
    end;
```

Процедура <арифметическое выражение>, в соответствии с грамматикой вызывает процедуру <слагаемое>:

```pascal
    procedure <слагаемое> ;
        begin
              BP:=false;
    	if <значение>  завершилось успешно then
    	    begin
     		BP:=true;
    		while (t = *  или  t = div ) and ( BP=true ) do
    		     begin
    			Перейти к следующей лексеме;
    			if <значение> завершилось неудачно then
     			    BP:=false;	
	    	     end; {while}
	        end; {if значение}
	    if  BP=true then успешное завершение 
	                     else неудачное завершение;
        end;	
```

И, наконец, процедура <слагаемое> вызывает процедуру <значение>, которая распознает переменные, константы или вызывает процедуру <арифметическое выражение>. Алгоритм процедуры <значение> имеет вид:

```pascal
    procedure значение;
        begin
     	BP:=false;
    	if t =  ид  или  t = конст    then
    	    begin
     		BP:=true;
    		Перейти к следующей лексеме;
    	    end {if ид или конст}	
                   else
       	         if t = (   then
     		  begin
                	       Перейти к следующей лексеме;
                                if <арифметическое выражение>  завершилось
                                                                                      успешно  then
    		         if  t = )   then 
	    	             begin
    			        BP:=true;	
                                       Перейти к следующей лексеме;
	    		   end; {if )}				       
    		  end; {if (}			
    	if BP = true then успешное завершение 
    	                   else неудачное завершение;
       end;	
```

Графически разбор этого предложения методом рекурсивного спуска выглядит так:

1)	Вызывается процедура <присваивание>, которая обнаружила    лексемы ид  и  :=  во входном потоке (рис. 8а).

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМРС8а.PNG)

2)	Процедура <присв> вызывает процедуру <арифметическое выражение> (рис. 8б)

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМРС8б.PNG)
   
3)	Процедура     <арифметическое выражение>    вызывает   процедуру <слагаемое> (рис. 9а).

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМРС9а.PNG)

4)	Процедура <слагаемое>. вызывает процедуру  <значение>, которая     обнаруживает лексему ид. Управление возвращается в  процедуру <слагаемое> (рис. 9б).

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМРС9б.PNG)
   
5)	Процедура <слагаемое> обнаруживает лексему div и вызывает процедуру <значение>, которая обнаруживает лексему конст. и  передаёт управление в процедуру <слагаемое>, которая передаёт     управление в процедуру <арифметическое выражение> (рис. 10a).

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМСР10а.PNG)
   
7)	Процедура <арифметическое выражение> распознаёт лексему – ,  затем   вызывает процедуру <слагаемое>, которая вызывает процедуру <значение>, которая распознаёт лексему ид и передаёт управление в процедуру <слагаемое> (рис. 10б).

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМСР10б.PNG)

7) Процедура <слагаемое> распознаёт лексему * ,  затем   вызывает процедуру <значение>, которая распознаёт лексему ид. Следующая лексема читается в процедуре <значение>. Эта лексема не относится  к данному предложению. Управление передаётся в процедуру <слагаемое>, которая формирует признак успешного завершения и передаёт управление в процедуру <арифметическое выражение>. Эта процедура, в свою очередь, успешно заканчивается и передаёт управление в процедуру <присваивание>, которая формирует признак успешного завершения. На этом разбор этого предложения заканчивается (рис.11). 

![](https://raw.githubusercontent.com/s-lana-nev/CW_MT_files/refs/heads/main/ТТМСР11.PNG)

Мы привели примеры грамматического разбора отдельных предложений методом рекурсивного спуска. Однако, этот метод применим и ко всей программе в целом. В этом случае для осуществления синтаксического анализа следует просто обратиться к процедуре, соответствующей нетерминальному символу <программа>. В результате работы этой процедуры будет построено дерево грамматического разбора для всей программы. 
